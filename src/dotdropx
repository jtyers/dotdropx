#!/bin/bash

# Provides extra dotdrop commands to ease usage.

# MIT License
# 
# Copyright (c) 2021 Jonny Tyers
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

usage="$(basename $0) [--cfg=<file>] [--sudo] [compare|difftool <file>|difftool-all|find <file>|git <command...>]"

set -eu

die() {
  echo "$@" >&2
  exit 1
}

# usage: askYN <question>
askYN() {
  echo -n "$@ [Y/n] " >&2
  read ans

  if [ "${ans:0:1}" == "y" ] || [ -z "$ans" ]; then
    return 0

  else
    return 1
  fi
}

# findFile reads config.yaml and spits out JSON for the matching
# key/src/dst. JSON is like { key: <key>, src: <src>, dst: <dst> }
findFile() {
  input="$1"

  /usr/bin/yq \
    --arg "search" "${input//$HOME/\~}" \
    -r \
    '
      .dotfiles
      | if has($search) then
          .[$search]
          | . * { key: $search }
        else
          to_entries
          | map(
            select(.value.src == $search or .value.dst == $search)
          )
          | .[0]
          | if length == 0 then
              # will exit with errcode 5
              error("could not find $search")
            else
              .
            end
          | .value * {key}
        end
      ' ${cfg_file:-config.yaml} \
    || die "could not find $input"
}

# usage: findFileOrParent <target file>
findFileOrParent() {
  # don't recurse beyond these directories
  stopAt=( "/etc" "$HOME" )
  stopIfContains=( ".git" )

  target="$1"
  targetBase=$(basename "$target")
  targetRel=""  # if return value is not same as target, this 
                # denotes the path from return val to target

  result=$(findFile "$target" 2>/dev/null || true)

  if [ -n "$result" ]; then
    # echo result but without $targetRel
    result=$(jq -re --arg path "$target" '. * { path: $path }' <<<"$result")

    echo "$result"
    return
  fi

  # now jump up to the parent directory, unless our directory is
  # in $stopAt or contains any of $stopIfContains
  while true; do
    if [ -z "$targetRel" ]; then
      targetRel=$(basename "$target")  # avoid trailing slashes on $targetRel
    else
      targetRel=$(basename "$target")/"$targetRel"
    fi

    target=$(dirname "$target")
    result=$(findFile "$target" 2>/dev/null || true)

    if [ -n "$result" ]; then
      # echo result, adding in $targetRel so the caller knows that
      # their target is beneath the return value's src/dst path
      result=$(jq -re \
        --arg path "$target" \
        --arg targetRel "$targetRel" \
        '. * { $path, $targetRel }' <<<"$result"
      )
      echo "$result"
      return
    fi

    doBreak=0
    if [ $target == / ]; then
      doBreak=1
    else
      for _stopAt in ${stopAt[@]}; do
        [ "$target" == "$_stopAt" ] && doBreak=1
      done

      if [ $doBreak -eq 0 ]; then
        for _stopIfContains in ${stopIfContains[@]}; do
          [ -e "$target/$_stopIfContains" ] && doBreak=1
        done
      fi
    fi

    [ $doBreak -eq 1 ] && break
  done

  return 1  # failed
}

editFiles() {
  ff=$(findFileOrParent "$1" || die "file $1 not in dotdrop")
  
  src=$(jq -r .src <<<"$ff")
  dst=$(jq -r .dst <<<"$ff")
  dst="${dst/\~/$HOME}"

  targetRel=$(jq -r '.targetRel | if . != null then . else "" end' <<<"$ff" || true)

  if [ -n "$targetRel" ]; then
    src="$cfg_dir/dotfiles/$src/$targetRel"
    dst="$dst/$targetRel"

  else
    src="$cfg_dir/dotfiles/$src"
  fi

  edit_cmd='${EDITOR:-nvim} +":windo diffthis" -o "$src" "$dst"'
  if [ $do_sudo -eq 1 ]; then
    # we would use sudoedit but we really want the difftool, not just a simple editor
    eval sudo $edit_cmd

  else
    eval $edit_cmd
  fi

}


do_compare=0
do_difftool=""
do_difftool_all=0
do_print_src=""
do_sudo=0
do_git=0
do_find=""
cfg_file=""
cfg_dir="."
dotdrop="dotdrop"

[ $# -ge 1 ] || die "$usage"

# the + at the start of the short-options string tells getopt to stop
# parsing at the first non-option argument, which allows us for example
# to do `dotdropx git status --short` without getopt greedily consuming
# the '--short' and erroring out
O=`getopt -n dotdropx \
    -l sudo:,cfg: \
    -- +c: "$@"` \
    || die "$usage"
eval set -- "$O"
while true; do
    case "$1" in
        -c|--cfg)	        cfg_file="$2";          shift; shift ;;
        --sudo)	          do_sudo=1;              shift ;;
        --)	                                      shift; break ;;
        *)	                                      break ;;  # do not shift
    esac
done

while true; do
    case "$1" in
        C|compare)	      do_compare=1;           shift ;;
        d|difftool)	      do_difftool="$2";       shift; shift ;;
        D|difftool-all)	  do_difftool_all=1;      shift ;;
        f|find)	          do_find="$2";           shift; shift ;;
        s|src)	          do_print_src="$2";      shift; shift ;;
        g|git)	          do_git=1;               shift; break ;;  # $@ gets passed to git
        --)			                                  shift; break ;;
        *)			          die "$1 unknown, usage: $usage" ;;
    esac
done

if [ $do_git -ne 1 ]; then
  [ $# -eq 0 ] || die "$usage"
fi

[ $do_sudo -eq 1 ] && dotdrop="sudo dotdrop"

args=""
gitargs=""

if [ -n "$cfg_file" ]; then
  cfg_dir=$(dirname $cfg_file)
  args="$args --cfg=$cfg_file"
  gitargs="$gitargs -C $cfg_dir"
fi

if [ "$do_git" -eq 1 ]; then
  [ "$do_compare" -eq 1 ] && die "cannot use --git with other arguments"
  [ "$do_sudo" -eq 1 ] && die "cannot use --git with other arguments"
  [ -n "$do_difftool" ] && die "cannot use --git with other arguments"
  [ "$do_difftool_all" -eq 1 ] && die "cannot use --git with other arguments"
  [ -n "$do_print_src" ] && die "cannot use --git with other arguments"
  [ -n "$do_find" ] && die "cannot use --git with other arguments"

  git $gitargs "$@"

elif [ "$do_compare" -eq 1 ]; then
  $dotdrop compare $args "$@" 2>&1 | grep -Ev '^=> compare '

elif [ -n "$do_difftool" ]; then
  editFiles "$do_difftool"

elif [ "$do_difftool_all" -eq 1 ]; then
  any=0
  for f in $($dotdrop compare $args 2>&1 | awk '/^\-\-\-/{ print $2 }'); do
    any=1
    editFiles "$f"
  done

  [ $any -eq 0 ] && echo "no files differ"

  if [ -n "$(git $gitargs status --porcelain)" ]; then
    if askYN "commit changes?"; then
      git $gitargs commit -av

      if [ -n "$(git $gitargs remote)" ] && askYN "push?"; then
        git $gitargs push
      fi
    fi
  fi

elif [ -n "$do_print_src" ]; then
  # since we're always dealing with full paths, convert ~ to $HOME
  ff=$(findFile "$do_print_src")
  src=$(jq -r .src <<<"$ff")
  src=${src/\~/$HOME}
  dst=$(jq -r .dst <<<"$ff")
  dst=${dst/\~/$HOME}
  key=$(jq -r .key <<<"$ff")

  case "$do_print_src" in
    "$src") echo $(readlink -f "$dst") ;;
    "$dst") echo $(readlink -f "$cfg_dir/dotfiles/$src") ;;
    "$key") echo $(readlink -f "$cfg_dir/dotfiles/$src") ;;
    *) die "?!" ;;
  esac

elif [ -n "$do_find" ]; then
  findFileOrParent "$do_find"

else
    die "$usage"

fi
